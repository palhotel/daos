#include<stdio.h>
#include<int.h>
#include<keyboard.h>
#include<mouse.h>

#define ADR_IDT   0x0026f800
#define LIMIT_IDT 0x000007ff
#define ADR_GDT   0x00270000
#define LIMIT_GDT 0x0000ffff

#define ADR_BOOTPACK    0x00280000
#define LIMIT_BOOTPACK  0x0007ffff

#define AR_DATA32_RW 0x4092
#define AR_CODE32_ER 0x409a
#define AR_INTGATE32 0x008e
#define ADR_BOOTINFO 0x00000ff0

//类似glibc
void io_hlt(void);
void io_cli(void);
void io_out8(int port, int data);
int io_load_eflags(void);
void io_store_eflags(int eflags);
void write_mem8(int addr, int data);
//设置中断标志位
void io_cli(void); //清理，CLI (Clear Interrupt Flag)
void io_sti(void); //STI（Set Interrupt Flag）
void io_stihlt(void);

//类似内核函数
void init_palette(void);
void set_palette(int start, int end, unsigned char *rgb);
//类似于GDI
void boxfill8(unsigned char* vram, int xsize, unsigned char c, int x0, int y0, int x1, int y1);

struct BootInfo{
  char  cyls;
  char  leds;
  char  vmode;
  char  reserve;
  short scrnx;
  short scrny;
  unsigned char *vram;
};

struct font_index_desc
{
    int bitmap_index;  // 字形位图数据的索引
    int adv_w;         // 字形的宽度
    int box_w;         // 字形的实际宽度
    int box_h;         // 字形的实际高度
    int ofs_x;         // 字形相对于原点的水平偏移
    int ofs_y;         // 字形相对于基线的垂直偏移
};
extern int ascii_bitmap[];
extern int cursor[];
extern struct font_index_desc glyph_dsc[];
void putfont8(char* vram, int xsize, int x, int y, char c, int* pbitmaps, int ascii);
void putstring(char* vram, int xsize, int x, int y, char c, int* pbitmaps, char* str, int len);
void putcursor(char* vram, int xsize, int x, int y, char c, int* pcursormap);

struct SegmentDescriptor {
  short limit_low, base_low;
  char base_mid, access_right;
  char limit_high, base_high;
};

struct GateDescriptor {
  short offset_low, selector;
  char dw_count, access_right;
  short offset_high;
};
void init_gdtidt(void);
void init_pic(void);

struct KEYBUF keybuf; //暂时不想使用循环队列，循环队列其实也很简单
struct MOUSEBUF mousebuf;

unsigned char mouse_db[3], mouse_phase;

void wait_KBC_sendready(void) {
  for (;;) {
    if ((io_in8(PORT_KEYSTA) & KEYSTA_SEND_NOTREADY) == 0) {
      break;
    }
  }
}

void init_keyboard(void) {
  wait_KBC_sendready();
  io_out8(PORT_KEYCMD, KEYCMD_WRITE_MODE);
  wait_KBC_sendready();
  io_out8(PORT_KEYDAT, KBC_MODE);
}

void enable_mouse(void) {
  wait_KBC_sendready();
  io_out8(PORT_KEYCMD, KEYCMD_SENDTO_MOUSE);
  wait_KBC_sendready();
  io_out8(PORT_KEYDAT, MOUSECMD_ENABLE);
}

void main(void) {
  int i;
  char *p;
  short *binfo_scrnx, *binfo_scrny;
  int *binfo_vram;
  struct BootInfo *binfo = (struct BootInfo *)ADR_BOOTINFO;
  // GDT/IDT完成初始化，开放CPU中断
  init_gdtidt();
  init_pic();
  io_sti();
  init_palette();
  //boot info
  //0xa0000是左上角的像素点
  binfo_scrnx = (short*)0xff4;
  binfo_scrny = (short*)0xff6;
  binfo_vram = (int*)0xff8;

  int xsize = *binfo_scrnx;
  int ysize = *binfo_scrny;
  unsigned char* vram = (char*)*binfo_vram;

  //先刷一个背景色 320*200
  boxfill8(vram, xsize, 15, 0, 0, 320, 200);
  //画一些东西
  boxfill8(vram, 320, 3, 150, 90, 170, 110);
  boxfill8(vram, 320, 5, 120, 90, 140, 110);
  boxfill8(vram, 320, 7, 135, 120, 155, 140);

  //绘制字符
  char strbuf[16]="Hello, World";
  putstring(vram, 320, 30, 50, 13, ascii_bitmap, strbuf, 16); 
  int mx = (binfo->scrnx - 16) / 2;
  int my = (binfo->scrny - 28 - 16) / 2;
  char kvmstr[16] = {0};
  sprintf(kvmstr, "(%d, %d)", mx, my);
  putstring(vram, 320, 20, 5, 13, ascii_bitmap, kvmstr, 16); 
  putcursor(vram, 320, mx, my, 0, cursor);
  io_out8(PIC0_IMR, 0xf9); // 开放PIC1以及键盘中断
  io_out8(PIC1_IMR, 0xef); // 开放鼠标中断

  init_keyboard();
  enable_mouse();

  mouse_phase = 0;
  int key_shift = 0;

  for(;;){
    io_cli();
    if(keybuf.next == 0 && mousebuf.next == 0){
      io_stihlt();
    } else {
      if(keybuf.next != 0){
        int e = keybuf.data[0];
        keybuf.next -- ;
        for(int j = 0; j < keybuf.next; j++){
          //move
          keybuf.data[j] = keybuf.data[j+1];
        }
        io_sti();

        char keyinput = ' ';
        if (e < 0x80) {
          if (key_shift == 0) {
            keyinput = keytable0[e];
          } else {
            keyinput = keytable1[e];
          }
        }
        struct BootInfo *binfo = (struct BootInfo *) ADR_BOOTINFO;
        char kvmstr[16] = {0};
        sprintf(kvmstr, "%c", (char)keyinput);
        boxfill8(binfo->vram, 320, 15, 200, 120, 200+64, 120+32);
        putstring(binfo->vram, 320, 216, 120, 13, ascii_bitmap, kvmstr, 16); 
      } else if(mousebuf.next != 0){
        int e = mousebuf.data[0];
        mousebuf.next -- ;
        for(int j = 0; j < mousebuf.next; j++){
          //move
          mousebuf.data[j] = mousebuf.data[j+1];
        }
        io_sti();

        if(mouse_phase == 0){
          if (e == 0xfa){
            mouse_phase = 1;
          }
        } else if(mouse_phase == 1){
          if((e & 0xc8) == 0x08){
            mouse_db[0] = e;
            mouse_phase = 2;
          }
        } else if(mouse_phase == 2){
          mouse_db[1] = e;
          mouse_phase = 3;
        } else if(mouse_phase == 3){
          mouse_db[2] = e;
          mouse_phase = 1;

          struct BootInfo *binfo = (struct BootInfo *) ADR_BOOTINFO;
          char kvmstr[16] = {0};
          int btn = mouse_db[0] & 0x07;
          int x = mouse_db[1];
          int y = mouse_db[2];
          if(mouse_db[0] & 0x10 != 0){
            x |= 0xffffff00;
          }
          if(mouse_db[0] & 0x20 != 0){
            y |= 0xffffff00;
          }
          y = -y;
          //clear old cursor
          boxfill8(binfo->vram, 320, 15, mx-8, my, mx+8, my+16);
          mx += (char)x;
          my += (char)y;
          if(mx < 16){
            mx = 16;
          }
          if(my < 0){
            my = 0;
          }
          if(mx > binfo->scrnx - 16){
            mx = binfo->scrnx - 16;
          }
          if(my > binfo->scrny - 16){
            my = binfo->scrny - 16;
          }
          sprintf(kvmstr, "%d %d %d", btn, x & 0xff, y & 0xff);
          boxfill8(binfo->vram, 320, 15, 200, 20, 200+120, 20+32);
          putstring(binfo->vram, 320, 216, 20, 13, ascii_bitmap, kvmstr, 16); 

          //update mouse
          char mousestr[16] = {0};
          sprintf(mousestr, "(%d,%d)", mx, my);
          boxfill8(binfo->vram, 320, 15, 20, 5, 4+100, 5+16);
          putstring(vram, 320, 20, 5, 13, ascii_bitmap, mousestr, 16); 
          
          putcursor(vram, 320, mx, my, 0, cursor);
        }
      }

    }
  }
}

void init_palette(void){
  static unsigned char table_rgb[16*3] = {
    0x00, 0x00, 0x00,
    0x66, 0x00, 0x00,
    0xcc, 0x00, 0x00,
    0xff, 0x00, 0x00,
    0x00, 0x66, 0x00,
    0x00, 0xcc, 0x00,
    0x00, 0xff, 0x00,
    0x00, 0x00, 0x66,
    0x00, 0x00, 0xcc,
    0x00, 0x00, 0xff,
    0xcc, 0xcc, 0x00,
    0xff, 0xff, 0x00,
    0xcc, 0x00, 0xcc,
    0xff, 0x00, 0xff,
    0x00, 0xff, 0xff,
    0xff, 0xff, 0xff,
  };
  set_palette(0, 15, table_rgb);
}

void set_palette(int start, int end, unsigned char *rgb){
  int i, eflags;
  eflags = io_load_eflags(); //记录中断许可标志的值
  io_cli();//中断许可标志设置为0
  io_out8(0x3c8, start); //将想要设定的调色板号码写入0x3c8，然后将rgb写入0x3c9
  for(i = start; i <= end; i++){
    io_out8(0x3c9, rgb[0]/4);
    io_out8(0x3c9, rgb[1]/4);
    io_out8(0x3c9, rgb[2]/4);
    rgb += 3;
  }
  io_store_eflags(eflags);
}

void boxfill8(unsigned char* vram, int xsize, unsigned char c, int x0, int y0, int x1, int y1){
  int x, y;
  for(y = y0; y <= y1; y++){
    for (x = x0; x<=x1; x++){
      vram[y  * xsize + x] = c;
    }
  }
}

int cursor[] = {
  0xfc,
  0x88,
  0x90,
  0x88,
  0xc4,
  0xb2,
  0x0a,
  0x06
};
int ascii_bitmap[] = {
    /* U+0020 ' ' */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    /* U+0021 '!' */
    0x0000, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0000, 0x0800, 0x0000, 0x0000, 0x0000,
    /* U+0022 '"' */
    0x0000, 0x1200, 0x1200, 0x1200, 0x1200, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    /* U+0023 '#' */
    0x0000, 0x0440, 0x0440, 0x0440, 0x0880, 0x3FE0, 0x0880, 0x0880, 0x0880, 0x3FE0, 0x1100, 0x1100, 0x1100, 0x0000, 0x0000, 0x0000,
    /* U+0024 '$' */
    0x0200, 0x0780, 0x0A40, 0x1240, 0x1200, 0x1200, 0x0E00, 0x0380, 0x0240, 0x0240, 0x1240, 0x0A80, 0x0700, 0x0200, 0x0000, 0x0000,
    /* U+0025 '%' */
    0x0000, 0x0E10, 0x1120, 0x1120, 0x1140, 0x1140, 0x0E40, 0x009C, 0x00A2, 0x0122, 0x0122, 0x0222, 0x021C, 0x0000, 0x0000, 0x0000,
    /* U+0026 '&' */
    0x0000, 0x0700, 0x0880, 0x0880, 0x0880, 0x0500, 0x0600, 0x0A00, 0x1110, 0x10A0, 0x1040, 0x08A0, 0x0710, 0x0000, 0x0000, 0x0000,
    /* U+0027 ''' */
    0x0000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    /* U+0028 '(' */
    0x0000, 0x0400, 0x0800, 0x0800, 0x0800, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0800, 0x0800, 0x0800, 0x0400,
    /* U+0029 ')' */
    0x0000, 0x1000, 0x0800, 0x0800, 0x0800, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0800, 0x0800, 0x0800, 0x1000,
    /* U+002A '*' */
    0x0000, 0x0800, 0x3E00, 0x0800, 0x1400, 0x1400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    /* U+002B '+' */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0200, 0x0200, 0x0200, 0x1FC0, 0x0200, 0x0200, 0x0200, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    /* U+002C ',' */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0800, 0x0800, 0x0800, 0x0000,
    /* U+002D '-' */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3C00, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    /* U+002E '.' */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0800, 0x0000, 0x0000, 0x0000,
    /* U+002F '/' */
    0x0000, 0x0400, 0x0400, 0x0800, 0x0800, 0x0800, 0x0800, 0x1000, 0x1000, 0x1000, 0x1000, 0x2000, 0x2000, 0x0000, 0x0000, 0x0000,
    /* U+0030 '0' */
    0x0000, 0x0700, 0x0880, 0x1040, 0x1040, 0x1040, 0x1040, 0x1040, 0x1040, 0x1040, 0x1040, 0x0880, 0x0700, 0x0000, 0x0000, 0x0000,
    /* U+0031 '1' */
    0x0000, 0x0100, 0x0300, 0x0500, 0x0900, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0000, 0x0000, 0x0000,
    /* U+0032 '2' */
    0x0000, 0x0780, 0x0880, 0x1040, 0x0040, 0x0040, 0x0080, 0x0080, 0x0100, 0x0200, 0x0400, 0x0800, 0x1FC0, 0x0000, 0x0000, 0x0000,
    /* U+0033 '3' */
    0x0000, 0x0700, 0x0880, 0x1080, 0x0080, 0x0180, 0x0700, 0x0080, 0x0040, 0x0040, 0x1040, 0x1880, 0x0700, 0x0000, 0x0000, 0x0000,
    /* U+0034 '4' */
    0x0000, 0x0080, 0x0180, 0x0280, 0x0480, 0x0480, 0x0880, 0x1080, 0x2080, 0x3FC0, 0x0080, 0x0080, 0x0080, 0x0000, 0x0000, 0x0000,
    /* U+0035 '5' */
    0x0000, 0x0FC0, 0x0800, 0x0800, 0x1000, 0x1F00, 0x1080, 0x0040, 0x0040, 0x0040, 0x1040, 0x0880, 0x0700, 0x0000, 0x0000, 0x0000,
    /* U+0036 '6' */
    0x0000, 0x0700, 0x0880, 0x1040, 0x1000, 0x1700, 0x1880, 0x1040, 0x1040, 0x1040, 0x1040, 0x0880, 0x0700, 0x0000, 0x0000, 0x0000,
    /* U+0037 '7' */
    0x0000, 0x0FC0, 0x0040, 0x0080, 0x0080, 0x0100, 0x0100, 0x0100, 0x0100, 0x0200, 0x0200, 0x0200, 0x0200, 0x0000, 0x0000, 0x0000,
    /* U+0038 '8' */
    0x0000, 0x0700, 0x0880, 0x1040, 0x1040, 0x0880, 0x0700, 0x0880, 0x1040, 0x1040, 0x1040, 0x0880, 0x0700, 0x0000, 0x0000, 0x0000,
    /* U+0039 '9' */
    0x0000, 0x0700, 0x0880, 0x1040, 0x1040, 0x1040, 0x1040, 0x08C0, 0x0740, 0x0040, 0x1040, 0x0880, 0x0700, 0x0000, 0x0000, 0x0000,
    /* U+003A ':' */
    0x0000, 0x0000, 0x0000, 0x0000, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1000, 0x0000, 0x0000, 0x0000,
    /* U+003B ';' */
    0x0000, 0x0000, 0x0000, 0x0000, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1000, 0x1000, 0x1000, 0x0000,
    /* U+003C '<' */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0040, 0x0380, 0x0C00, 0x1000, 0x0C00, 0x0380, 0x0040, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    /* U+003D '=' */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1FC0, 0x0000, 0x0000, 0x0000, 0x1FC0, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    /* U+003E '>' */
    0x0000, 0x0000, 0x0000, 0x0000, 0x1000, 0x0E00, 0x0180, 0x0040, 0x0180, 0x0E00, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    /* U+003F '?' */
    0x0000, 0x0700, 0x0880, 0x1040, 0x1040, 0x0040, 0x0080, 0x0100, 0x0200, 0x0200, 0x0200, 0x0000, 0x0200, 0x0000, 0x0000, 0x0000,
    /* U+0040 '@' */
    0x0000, 0x00FC, 0x0303, 0x0400, 0x0874, 0x088C, 0x1104, 0x1204, 0x1208, 0x1208, 0x1208, 0x1119, 0x08EE, 0x0400, 0x0301, 0x00FE,
    /* U+0041 'A' */
    0x0000, 0x0100, 0x0280, 0x0280, 0x0280, 0x0440, 0x0440, 0x0440, 0x0FE0, 0x0820, 0x0820, 0x1010, 0x1010, 0x0000, 0x0000, 0x0000,
    /* U+0042 'B' */
    0x0000, 0x1FC0, 0x1020, 0x1010, 0x1010, 0x1020, 0x1FC0, 0x1020, 0x1010, 0x1010, 0x1010, 0x1020, 0x1FC0, 0x0000, 0x0000, 0x0000,
    /* U+0043 'C' */
    0x0000, 0x03E0, 0x0410, 0x0808, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0808, 0x0410, 0x03E0, 0x0000, 0x0000, 0x0000,
    /* U+0044 'D' */
    0x0000, 0x1FC0, 0x1020, 0x1010, 0x1008, 0x1008, 0x1008, 0x1008, 0x1008, 0x1008, 0x1010, 0x1020, 0x1FC0, 0x0000, 0x0000, 0x0000,
    /* U+0045 'E' */
    0x0000, 0x1FF0, 0x1000, 0x1000, 0x1000, 0x1000, 0x1FE0, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1FF0, 0x0000, 0x0000, 0x0000,
    /* U+0046 'F' */
    0x0000, 0x1FE0, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1FC0, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000, 0x0000, 0x0000,
    /* U+0047 'G' */
    0x0000, 0x03C0, 0x0420, 0x0810, 0x1000, 0x1000, 0x1000, 0x10F8, 0x1008, 0x1008, 0x0810, 0x0420, 0x03C0, 0x0000, 0x0000, 0x0000,
    /* U+0048 'H' */
    0x0000, 0x1010, 0x1010, 0x1010, 0x1010, 0x1010, 0x1FF0, 0x1010, 0x1010, 0x1010, 0x1010, 0x1010, 0x1010, 0x0000, 0x0000, 0x0000,
    /* U+0049 'I' */
    0x0000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000, 0x0000, 0x0000,
    /* U+004A 'J' */
    0x0000, 0x0080, 0x0080, 0x0080, 0x0080, 0x0080, 0x0080, 0x0080, 0x0080, 0x1080, 0x1080, 0x1080, 0x0F00, 0x0000, 0x0000, 0x0000,
    /* U+004B 'K' */
    0x0000, 0x1010, 0x1020, 0x1040, 0x1080, 0x1100, 0x1300, 0x1500, 0x1880, 0x1040, 0x1040, 0x1020, 0x1010, 0x0000, 0x0000, 0x0000,
    /* U+004C 'L' */
    0x0000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1FC0, 0x0000, 0x0000, 0x0000,
    /* U+004D 'M' */
    0x0000, 0x1004, 0x180C, 0x180C, 0x1414, 0x1414, 0x1224, 0x1224, 0x1144, 0x1144, 0x1144, 0x1084, 0x1084, 0x0000, 0x0000, 0x0000,
    /* U+004E 'N' */
    0x0000, 0x1010, 0x1810, 0x1410, 0x1410, 0x1210, 0x1110, 0x1110, 0x1090, 0x1050, 0x1050, 0x1030, 0x1010, 0x0000, 0x0000, 0x0000,
    /* U+004F 'O' */
    0x0000, 0x03C0, 0x0420, 0x0810, 0x1008, 0x1008, 0x1008, 0x1008, 0x1008, 0x1008, 0x0810, 0x0420, 0x03C0, 0x0000, 0x0000, 0x0000,
    /* U+0050 'P' */
    0x0000, 0x1FC0, 0x1020, 0x1010, 0x1010, 0x1010, 0x1020, 0x1FC0, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000, 0x0000, 0x0000,
    /* U+0051 'Q' */
    0x0000, 0x03C0, 0x0420, 0x0810, 0x1008, 0x1008, 0x1008, 0x1008, 0x1008, 0x1008, 0x08D8, 0x0430, 0x03D8, 0x0000, 0x0000, 0x0000,
    /* U+0052 'R' */
    0x0000, 0x1FC0, 0x1020, 0x1010, 0x1010, 0x1010, 0x1020, 0x1FC0, 0x1080, 0x1040, 0x1040, 0x1020, 0x1010, 0x0000, 0x0000, 0x0000,
    /* U+0053 'S' */
    0x0000, 0x07C0, 0x0820, 0x1010, 0x1000, 0x0800, 0x0700, 0x00E0, 0x0010, 0x0010, 0x1010, 0x0820, 0x07C0, 0x0000, 0x0000, 0x0000,
    /* U+0054 'T' */
    0x0000, 0x3FE0, 0x0200, 0x0200, 0x0200, 0x0200, 0x0200, 0x0200, 0x0200, 0x0200, 0x0200, 0x0200, 0x0200, 0x0000, 0x0000, 0x0000,
    /* U+0055 'U' */
    0x0000, 0x1010, 0x1010, 0x1010, 0x1010, 0x1010, 0x1010, 0x1010, 0x1010, 0x1010, 0x1010, 0x0820, 0x07C0, 0x0000, 0x0000, 0x0000,
    /* U+0056 'V' */
    0x0000, 0x1010, 0x1010, 0x0820, 0x0820, 0x0820, 0x0440, 0x0440, 0x0440, 0x0280, 0x0280, 0x0100, 0x0100, 0x0000, 0x0000, 0x0000,
    /* U+0057 'W' */
    0x0000, 0x2040, 0x20A0, 0x10A1, 0x10A1, 0x1111, 0x1111, 0x0912, 0x0A0A, 0x0A0A, 0x0A0A, 0x0404, 0x0404, 0x0000, 0x0000, 0x0000,
    /* U+0058 'X' */
    0x0000, 0x1010, 0x0820, 0x0440, 0x0440, 0x0280, 0x0100, 0x0280, 0x0440, 0x0440, 0x0820, 0x1010, 0x2008, 0x0000, 0x0000, 0x0000,
    /* U+0059 'Y' */
    0x0000, 0x2020, 0x1040, 0x1040, 0x0880, 0x0500, 0x0500, 0x0200, 0x0200, 0x0200, 0x0200, 0x0200, 0x0200, 0x0000, 0x0000, 0x0000,
    /* U+005A 'Z' */
    0x0000, 0x1FE0, 0x0040, 0x0080, 0x0080, 0x0100, 0x0200, 0x0200, 0x0400, 0x0800, 0x0800, 0x1000, 0x3FE0, 0x0000, 0x0000, 0x0000,
    /* U+005B '[' */
    0x0000, 0x1C00, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1C00,
    /* U+005C '\' */
    0x0000, 0x2000, 0x2000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0800, 0x0800, 0x0800, 0x0800, 0x0400, 0x0400, 0x0000, 0x0000, 0x0000,
    /* U+005D ']' */
    0x0000, 0x3800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x3800,
    /* U+005E '^' */
    0x0000, 0x0400, 0x0A00, 0x0A00, 0x1100, 0x1100, 0x2080, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    /* U+005F '_' */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3FE0,
    /* U+0060 '`' */
    0x0000, 0x1000, 0x0800, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    /* U+0061 'a' */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0780, 0x0840, 0x1040, 0x01C0, 0x0E40, 0x1040, 0x1040, 0x10C0, 0x0F40, 0x0000, 0x0000, 0x0000,
    /* U+0062 'b' */
    0x0000, 0x1000, 0x1000, 0x1000, 0x1700, 0x1880, 0x1040, 0x1040, 0x1040, 0x1040, 0x1040, 0x1880, 0x1700, 0x0000, 0x0000, 0x0000,
    /* U+0063 'c' */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0700, 0x0880, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0880, 0x0700, 0x0000, 0x0000, 0x0000,
    /* U+0064 'd' */
    0x0000, 0x0040, 0x0040, 0x0040, 0x0740, 0x08C0, 0x1040, 0x1040, 0x1040, 0x1040, 0x1040, 0x08C0, 0x0740, 0x0000, 0x0000, 0x0000,
    /* U+0065 'e' */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0700, 0x0880, 0x1040, 0x1040, 0x1FC0, 0x1000, 0x1040, 0x0880, 0x0700, 0x0000, 0x0000, 0x0000,
    /* U+0066 'f' */
    0x0000, 0x0C00, 0x1000, 0x1000, 0x3C00, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000, 0x0000, 0x0000,
    /* U+0067 'g' */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0740, 0x08C0, 0x1040, 0x1040, 0x1040, 0x1040, 0x1040, 0x08C0, 0x0740, 0x0040, 0x1080, 0x0F00,
    /* U+0068 'h' */
    0x0000, 0x1000, 0x1000, 0x1000, 0x1700, 0x1880, 0x1080, 0x1080, 0x1080, 0x1080, 0x1080, 0x1080, 0x1080, 0x0000, 0x0000, 0x0000,
    /* U+0069 'i' */
    0x0000, 0x1000, 0x0000, 0x0000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000, 0x0000, 0x0000,
    /* U+006A 'j' */
    0x0000, 0x1000, 0x0000, 0x0000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x6000,
    /* U+006B 'k' */
    0x0000, 0x1000, 0x1000, 0x1000, 0x1040, 0x1080, 0x1100, 0x1200, 0x1600, 0x1900, 0x1100, 0x1080, 0x1040, 0x0000, 0x0000, 0x0000,
    /* U+006C 'l' */
    0x0000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000, 0x0000, 0x0000,
    /* U+006D 'm' */
    0x0000, 0x0000, 0x0000, 0x0000, 0x1738, 0x18C4, 0x1084, 0x1084, 0x1084, 0x1084, 0x1084, 0x1084, 0x1084, 0x0000, 0x0000, 0x0000,
    /* U+006E 'n' */
    0x0000, 0x0000, 0x0000, 0x0000, 0x1700, 0x1880, 0x1080, 0x1080, 0x1080, 0x1080, 0x1080, 0x1080, 0x1080, 0x0000, 0x0000, 0x0000,
    /* U+006F 'o' */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0700, 0x0880, 0x1040, 0x1040, 0x1040, 0x1040, 0x1040, 0x0880, 0x0700, 0x0000, 0x0000, 0x0000,
    /* U+0070 'p' */
    0x0000, 0x0000, 0x0000, 0x0000, 0x1700, 0x1880, 0x1040, 0x1040, 0x1040, 0x1040, 0x1040, 0x1880, 0x1F00, 0x1000, 0x1000, 0x1000,
    /* U+0071 'q' */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0740, 0x08C0, 0x1040, 0x1040, 0x1040, 0x1040, 0x1040, 0x08C0, 0x0740, 0x0040, 0x0040, 0x0040,
    /* U+0072 'r' */
    0x0000, 0x0000, 0x0000, 0x0000, 0x1600, 0x1800, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x0000, 0x0000, 0x0000,
    /* U+0073 's' */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0F00, 0x1080, 0x1000, 0x1000, 0x0F00, 0x0080, 0x0080, 0x1080, 0x0F00, 0x0000, 0x0000, 0x0000,
    /* U+0074 't' */
    0x0000, 0x0000, 0x1000, 0x1000, 0x3C00, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1C00, 0x0000, 0x0000, 0x0000,
    /* U+0075 'u' */
    0x0000, 0x0000, 0x0000, 0x0000, 0x1080, 0x1080, 0x1080, 0x1080, 0x1080, 0x1080, 0x1080, 0x1180, 0x0E80, 0x0000, 0x0000, 0x0000,
    /* U+0076 'v' */
    0x0000, 0x0000, 0x0000, 0x0000, 0x4100, 0x4100, 0x2200, 0x2200, 0x1400, 0x1400, 0x1400, 0x0800, 0x0800, 0x0000, 0x0000, 0x0000,
    /* U+0077 'w' */
    0x0000, 0x0000, 0x0000, 0x0000, 0x2108, 0x2108, 0x1290, 0x1290, 0x1450, 0x1450, 0x1450, 0x0820, 0x0820, 0x0000, 0x0000, 0x0000,
    /* U+0078 'x' */
    0x0000, 0x0000, 0x0000, 0x0000, 0x2080, 0x1100, 0x0A00, 0x0A00, 0x0400, 0x0A00, 0x0A00, 0x1100, 0x2080, 0x0000, 0x0000, 0x0000,
    /* U+0079 'y' */
    0x0000, 0x0000, 0x0000, 0x0000, 0x4100, 0x4100, 0x4200, 0x2200, 0x2200, 0x1400, 0x1400, 0x1400, 0x0C00, 0x0800, 0x0800, 0x3000,
    /* U+007A 'z' */
    0x0000, 0x0000, 0x0000, 0x0000, 0x3F80, 0x0100, 0x0200, 0x0200, 0x0400, 0x0800, 0x0800, 0x1000, 0x3F80, 0x0000, 0x0000, 0x0000,
    /* U+007B '{' */
    0x0000, 0x0600, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x3000, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0600,
    /* U+007C '|' */
    0x0000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000,
    /* U+007D '}' */
    0x0000, 0x3000, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0600, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x0800, 0x3000,
    /* U+007E '~' */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1C40, 0x2380, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
};

//绘制一个字符，颜色c。
void putfont8(char *vram, int xsize, int x, int y, char c, int* pbitmaps, int ascii){
  int i;
  int oneline = 0;

  int idx = ascii - 0x20;
  int* font = pbitmaps + 16*idx;
  
  for (i = 0; i < 16; i++){
    oneline = font[i];
    for(int j = 15; j >= 0; j--){
      if( ((oneline >> j) & 1) != 0){
        vram[(y + i) * xsize + x - j] = c; //j from 15 to 0, so - j ?
      }
    }
  }
}
void putstring(char* vram, int xsize, int x, int y, char c, int* pbitmaps, char* str, int len){
  int fontsize = 12;
  for(int i = 0; i < len; i++){
    if(str[i] == '\0'){
      break;
    }
    putfont8(vram, xsize, x + fontsize * i, y, c, pbitmaps, str[i]);
  }
}

void putcursor(char* vram, int xsize, int x, int y, char c, int* pcursormap){
  if(x > xsize - 8){
    x = xsize - 8;
  }
  if(y > xsize * 3 / 4 - 8){
    y = xsize * 3 / 4 - 8;
  }
  int* pfont = pcursormap;
  int i; 
  int j;
  for (i = 0; i < 8; i++){
    int oneline = pfont[i];
    for(int j = 7; j >= 0; j--){
      if( ((oneline >> j) & 1) != 0){
        vram[(y + i) * xsize + x - j] = c;
      }
    }
  }
}

void init_pic(void) {
  //PIC0: Master, PIC1: Slave
  //ICW：initial control word
  // 禁止所有中断
  io_out8(PIC0_IMR, 0xff);
  io_out8(PIC1_IMR, 0xff);

  io_out8(PIC0_ICW1, 0x11); // 边缘触发模式 固定值
  io_out8(PIC0_ICW2, 0x20); // IRQ0-7由INT20-27接收 设置中断号
  io_out8(PIC0_ICW3, 1 << 2); // PIC1由IRQ2连接 主从连接设定 00000100 第三个管脚s
  io_out8(PIC0_ICW4, 0x01); // 无缓冲区模式 固定值

  io_out8(PIC1_ICW1, 0x11); // 边缘触发模式
  io_out8(PIC1_ICW2, 0x28); // IRQ8-15由INT28-2f接收
  io_out8(PIC1_ICW3, 2); // PIC1由IRQ2连接 00000010 从PIC这里填写主PIC的管脚
  io_out8(PIC1_ICW4, 0x01); // 无缓冲区模式

  io_out8(PIC0_IMR, 0xfb); // PIC1以外中断全部禁止
  io_out8(PIC1_IMR, 0xff); // 禁止全部中断
}

//鼠标
void int_handler2c(int *esp) {
  io_out8(PIC1_OCW2, 0x64); // 通知PIC1 IRQ-12的受理已经完成
  io_out8(PIC0_OCW2, 0x62); // 通知PIC0 IRQ-02的受理已经完成
  unsigned char data = io_in8(PORT_KEYDAT);
  if(mousebuf.next < 32){
    mousebuf.data[mousebuf.next] = data;
    mousebuf.next ++ ;
  }
}
//键盘
void int_handler21(int *esp) {
  io_out8(PIC0_OCW2, 0x61); // 通知PIC IRQ-1的受理已经完成
  unsigned char data = io_in8(PORT_KEYDAT);
  if(keybuf.next < 32){
    keybuf.data[keybuf.next] = data;
    keybuf.next ++ ;
  }
}

void int_handler27(int *esp) {
	io_out8(PIC0_OCW2, 0x67);

	return;
}

void init_gdtidt(void) {
  struct SegmentDescriptor *gdt = (struct SegmentDescriptor *)ADR_GDT;
  struct GateDescriptor *idt = (struct GateDescriptor *)ADR_IDT;

  for (int i = 0; i <= LIMIT_GDT / 8; i++) {
    set_segmdesc(gdt + i, 0, 0, 0);
  }

  set_segmdesc(gdt + 1, 0xffffffff, 0x00000000, AR_DATA32_RW);
  set_segmdesc(gdt + 2, LIMIT_BOOTPACK, ADR_BOOTPACK, AR_CODE32_ER);
  load_gdtr(LIMIT_GDT, ADR_GDT);

  for (int i = 0; i <= LIMIT_IDT / 8; i++) {
    set_gatedesc(idt + i, 0, 0, 0);
  }
  load_idtr(LIMIT_IDT, ADR_IDT);

  set_gatedesc(idt + 0x21, (int)asm_int_handler21, 2 * 8, AR_INTGATE32);
  set_gatedesc(idt + 0x27, (int)asm_int_handler27, 2 * 8, AR_INTGATE32);
  set_gatedesc(idt + 0x2c, (int)asm_int_handler2c, 2 * 8, AR_INTGATE32);
}

void set_segmdesc(struct SegmentDescriptor *sd, unsigned int limit, int base, int ar) {
  if (limit > 0xfffff) {
    ar |= 0x8000; // G_bit = 1
    limit /= 0x1000;
  }

  sd->limit_low = limit & 0xffff;
  sd->base_low = base & 0xffff;
  sd->base_mid = (base >> 16) & 0xff;
  sd->access_right = ar & 0xff;
  sd->limit_high = ((limit >> 16) & 0x0f) | ((ar >> 8) | 0xf0);
  sd->base_high = (base >> 24) & 0xff;
}

void set_gatedesc(struct GateDescriptor *gd, int offset, int selector, int ar) {
  gd->offset_low = offset & 0xffff;
  gd->selector = selector;
  gd->dw_count = (ar >> 8) & 0xff;
  gd->access_right = ar & 0xff;
  gd->offset_high = (offset >> 16) & 0xffff;
}

